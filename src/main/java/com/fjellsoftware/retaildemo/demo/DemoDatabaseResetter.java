/*
 * Â© 2023. This work is openly licensed via CC0 1.0.
 * https://creativecommons.org/publicdomain/zero/1.0/
 */

package com.fjellsoftware.retaildemo.demo;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fjellsoftware.retaildemo.ApplicationInternalException;
import com.fjellsoftware.retaildemo.CoreDependencies;
import com.fjellsoftware.retaildemo.LoggerInitializer;
import com.fjellsoftware.retaildemo.autogenerated.orm.main.*;
import com.zaxxer.hikari.HikariDataSource;
import io.loppi.orm.PostgresExecutionException;
import io.loppi.orm.includablevalues.IncludableIdValue;
import io.loppi.orm.includablevalues.IncludableOffsetDateTime;
import io.loppi.orm.includablevalues.IncludableUUID;
import io.loppi.orm.metamodel.EntityMetadata;
import io.loppi.orm.metamodel.ScalarAttribute;
import io.loppi.orm.query.QueryExecutionPluralResult;
import io.loppi.orm.query.TableQuery;
import io.loppi.orm.query.tablequerybuilder.TableQueryBuilder;
import io.loppi.orm.serviceconfiguration.ORMServiceConfigurationVersionBeta;

import javax.sql.DataSource;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

public class DemoDatabaseResetter {

    public static void main(String[] args) throws PostgresExecutionException {
        LoggerInitializer.initializeDevelopmentConsoleLogger();
        HikariDataSource dataSource = CoreDependencies.createDataSource(System.getProperty("user.home"));
        OffsetDateTime offsetDateTime2022 =
                OffsetDateTime.of(2022, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);
        resetDatabase(dataSource, offsetDateTime2022);
    }

    // Removes all records created after deleteNewerThan
    public static void resetDatabase(RetailDemoORMService loppiService, OffsetDateTime deleteNewerThan)
            throws PostgresExecutionException {
        resetDatabase(loppiService, deleteNewerThan, OffsetDateTime.now().plusHours(1));
    }

    public static void resetDatabase(DataSource dataSource, OffsetDateTime deleteNewerThan)
            throws PostgresExecutionException {
        RetailDemoORMService loppiService = new RetailDemoORMService(
                dataSource, new ORMServiceConfigurationVersionBeta());
        resetDatabase(loppiService, deleteNewerThan);
    }

    private static final int batchSize = 100;
    private static final ObjectMapper objectMapper = new ObjectMapper();
    public static void resetDatabase(
            RetailDemoORMService retailDemoORMService, OffsetDateTime lowerThreshold, OffsetDateTime upperThreshold)
            throws PostgresExecutionException {
        RetailDemoDatabaseService databaseServiceJDBC = retailDemoORMService.getDatabaseServiceJDBC();
        List<TableResetInfo<?>> tableResetInfos = collectTablesToReset(retailDemoORMService);
        for (TableResetInfo<?> tableResetInfo : tableResetInfos) {
            boolean shouldContinue = true;
            while(shouldContinue) {
                List<RetailDemoRowToMutate> rowsToDelete = new ArrayList<>();
                TableQueryBuilder<?> queryBuilder = databaseServiceJDBC.createTableQueryBuilder(tableResetInfo.entityMetadata, batchSize);
                ScalarAttribute idAttribute = tableResetInfo.idAttribute;
                TableQuery build = ((TableQueryBuilder) queryBuilder.includeScalar(idAttribute)
                        .where().between(tableResetInfo.createdAtAttribute, lowerThreshold, upperThreshold).end()).build();
                QueryExecutionPluralResult queryExecutionResult = databaseServiceJDBC.executeTableQuery(build);
                List<Map<String, Object>> results;
                try {
                    results = objectMapper.readValue(queryExecutionResult.toJson(), List.class);
                } catch (JsonProcessingException e) {
                    throw new ApplicationInternalException("Failed to parse query result into List<Map>>.", e);
                }
                for (Map<String, Object> result : results) {
                    Object id = result.get(idAttribute.getName());
                    if(idAttribute.getElementClass().equals(IncludableUUID.class)){
                        id = UUID.fromString(((String) id));
                    }
                    rowsToDelete.add(tableResetInfo.createRowToDelete.apply(id));
                }
                shouldContinue = rowsToDelete.size() == batchSize;
                databaseServiceJDBC.executeMutation(rowsToDelete);
            }
        }
    }

    private static List<TableResetInfo<?>> collectTablesToReset(RetailDemoORMService retailDemoORMService){
        RetailDemoMeta meta = retailDemoORMService.getMeta();
        LoginSessionMeta loginSessionMeta = meta.getLoginSessionMeta();
        OrderLineMeta orderLineMeta = meta.getOrderLineMeta();
        ProductMeta productMeta = meta.getProductMeta();
        PurchaseOrderMeta purchaseOrderMeta = meta.getPurchaseOrderMeta();
        UserAccountMeta userAccountMeta = meta.getUserAccountMeta();
        return List.of(
                new TableResetInfo<>(loginSessionMeta.getEntityMetadata(), loginSessionMeta.createdAt,
                        loginSessionMeta.loginSessionId, (id) -> new LoginSessionToDelete((UUID) id)),
                new TableResetInfo<>(orderLineMeta.getEntityMetadata(), orderLineMeta.createdAt,
                        orderLineMeta.orderLineId, (id) -> new OrderLineToDelete(((int) id))),
                new TableResetInfo<>(productMeta.getEntityMetadata(), productMeta.createdAt,
                        productMeta.productId, (id) -> new ProductToDelete(((int) id))),
                new TableResetInfo<>(purchaseOrderMeta.getEntityMetadata(), purchaseOrderMeta.createdAt,
                        purchaseOrderMeta.purchaseOrderId, (id) -> new PurchaseOrderToDelete(((int) id))),
                new TableResetInfo<>(userAccountMeta.getEntityMetadata(), userAccountMeta.createdAt,
                        userAccountMeta.userAccountId, (id) -> new UserAccountToDelete(((UUID) id)))
        );
    }

    record TableResetInfo<T extends RetailDemoTableQueryResult>(
            EntityMetadata<T> entityMetadata, ScalarAttribute<T, IncludableOffsetDateTime> createdAtAttribute,
            ScalarAttribute<T, ? extends IncludableIdValue> idAttribute,
            Function<Object, ? extends RetailDemoRowToDelete> createRowToDelete){}
}
