/*
 * Â© 2023. This work is openly licensed via CC0 1.0.
 * https://creativecommons.org/publicdomain/zero/1.0/
 */

package com.fjellsoftware.retaildemo.demo;

import com.fjellsoftware.javafunctionalutils.opt.Opt;
import com.fjellsoftware.javafunctionalutils.opt.Some;
import com.fjellsoftware.retaildemo.ApplicationInternalException;
import com.fjellsoftware.retaildemo.CoreDependencies;
import com.fjellsoftware.retaildemo.LoggerInitializer;
import com.fjellsoftware.retaildemo.autogenerated.orm.*;
import com.zaxxer.hikari.HikariDataSource;
import io.loppi.orm.query.DatabaseQuery;
import io.loppi.orm.PostgresExecutionException;
import io.loppi.orm.query.QueryBuilder;
import io.loppi.orm.QueryExecutionResult;
import io.loppi.includablevalues.*;
import io.loppi.orm.metamodel.EntityMetadata;
import io.loppi.orm.metamodel.ScalarAttribute;
import com.fjellsoftware.javafunctionalutils.ImmutableList;

import javax.sql.DataSource;
import java.lang.reflect.InvocationTargetException;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class DemoDatabaseResetter {

    public static void main(String[] args) throws PostgresExecutionException {
        LoggerInitializer.initializeDevelopmentConsoleLogger();
        HikariDataSource dataSource = CoreDependencies.createDataSource(System.getProperty("user.home"));
        OffsetDateTime offsetDateTime2022 = OffsetDateTime.of(2022, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);
        resetDatabase(dataSource, offsetDateTime2022);
    }

    public static void resetDatabase(LoppiServiceRetailDemo loppiService, OffsetDateTime lowerThreshold, OffsetDateTime upperThreshold)
            throws PostgresExecutionException {
        List<RetailDemoRowToMutate> mutation = new ArrayList<>();
        DatabaseServiceJDBCRetailDemo databaseServiceJDBC = loppiService.getDatabaseServiceJDBC();
        MetaRetailDemo meta = loppiService.getMeta();

        // If we only wanted to delete rows for one type/table, we could do like this:
//            UserAccountMeta userAccountMeta = meta.getUserAccountMeta();
//            ImmutableList<UserAccountResult> userAccounts = fetchRowsToDeleteForMeta(databaseServiceJDBC,
//                    userAccountMeta.getEntityMetadata(), userAccountMeta.userAccountId, userAccountMeta.createdAt);
//            for (UserAccountResult userAccount : userAccounts) {
//                int id = ((IntValue) userAccount.getUserAccountId()).getValue();
//                mutation.add(new UserAccountToDelete(id));
//            }

        // Here we use reflection on all entities and create a mutation that removes all rows older than
        // deleteNewerThan from the table associated with an entity, for each entity.
        for (EntityMetadata<? extends RetailDemoDatabaseQueryResult> entityMetadata : meta.getLoppiMetamodel().getAllEntityMetadatas()) {
            if(entityMetadata.equals(meta.getMetricKindMeta().getEntityMetadata()) ||
                    entityMetadata.equals(meta.getMetricValueMeta().getEntityMetadata())){
                continue;
            }
            List<RetailDemoRowToDelete> rowToDeletesForEntity = createRowToDeletesForEntity(databaseServiceJDBC, entityMetadata, lowerThreshold, upperThreshold);
            mutation.addAll(rowToDeletesForEntity);
        }

        databaseServiceJDBC.executeMutation(mutation);
    }

    // Removes all records created after deleteNewerThan
    public static void resetDatabase(LoppiServiceRetailDemo loppiService, OffsetDateTime deleteNewerThan)
            throws PostgresExecutionException {
        resetDatabase(loppiService, deleteNewerThan, OffsetDateTime.now().plusHours(1));
    }

    public static void resetDatabase(DataSource dataSource, OffsetDateTime deleteNewerThan)
            throws PostgresExecutionException {
        LoppiServiceRetailDemo loppiService = new LoppiServiceRetailDemo(dataSource);
        resetDatabase(loppiService, deleteNewerThan);
    }

    private static List<RetailDemoRowToDelete> createRowToDeletesForEntity(
            DatabaseServiceJDBCRetailDemo databaseService, EntityMetadata<?> entityMetadata,
            OffsetDateTime lowerThreshold, OffsetDateTime upperThreshold) throws PostgresExecutionException {
        ScalarAttribute<?, ? extends IncludableIdValue> idAttribute = entityMetadata.getIdAttribute();
        Opt<? extends ScalarAttribute<?, ? extends IncludableScalarValue>> createdAtOpt = entityMetadata.tryGetScalarAttribute("createdAt");
        if(!(createdAtOpt instanceof Some<? extends ScalarAttribute<?, ? extends IncludableScalarValue>> some)){
            return Collections.emptyList();
        }
        ScalarAttribute<?, ? extends IncludableScalarValue> createdAt = some.value();

        ImmutableList<RetailDemoDatabaseQueryResult> retailDemoDatabaseQueryResults =
                fetchRowsToDeleteForMeta(databaseService, entityMetadata, idAttribute, createdAt, lowerThreshold, upperThreshold);

        List<RetailDemoRowToDelete> rowsToDelete = new ArrayList<>();
        for (RetailDemoDatabaseQueryResult retailDemoDatabaseQueryResult : retailDemoDatabaseQueryResults) {
            try {
                Object obj = idAttribute.getGetterMethod().invoke(retailDemoDatabaseQueryResult);
                IncludableValue includableId = (IncludableValue) obj;
                Object id;
                if(includableId instanceof UUIDValue uuidValue){
                    id = uuidValue.getValue();
                }
                else if(includableId instanceof IntValue intValue){
                    id = intValue.getValue();
                }
                else id = ((LongValue) includableId).getValue();
                RetailDemoRowToDelete rowToDelete = ((RetailDemoRowToDelete) entityMetadata.getRowToDeleteMetadata()
                        .getRowToDeleteConstructor().newInstance(id));
                rowsToDelete.add(rowToDelete);
            } catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {
                throw new ApplicationInternalException("Reflection exception while trying to delete old data.", e);
            }
        }
        return rowsToDelete;
    }

    private static ImmutableList<RetailDemoDatabaseQueryResult> fetchRowsToDeleteForMeta(
            DatabaseServiceJDBCRetailDemo databaseService,
            EntityMetadata entityMetadata,
            ScalarAttribute idAttribute,
            ScalarAttribute createdAtAttribute,
            OffsetDateTime lowerThreshold, OffsetDateTime upperThreshold) throws PostgresExecutionException {
        QueryBuilder<RetailDemoDatabaseQueryResult> queryBuilder = databaseService.createQueryBuilder(entityMetadata.getQueryResultClass(), 100);
        DatabaseQuery<RetailDemoDatabaseQueryResult> query =
                ((QueryBuilder) queryBuilder.includeScalar(idAttribute)
                .includeScalar(createdAtAttribute)
                .where().between(createdAtAttribute, lowerThreshold, upperThreshold).end()).build();
        QueryExecutionResult<RetailDemoDatabaseQueryResult> queryResult = databaseService.executeQuery(query);
        return queryResult.deserialize();
    }
}
