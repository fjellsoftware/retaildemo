/*
 * Â© 2023. This work is openly licensed via CC0 1.0.
 * https://creativecommons.org/publicdomain/zero/1.0/
 */

package com.fjellsoftware.retaildemo;

import com.fjellsoftware.javafunctionalutils.ImmutableList;
import com.fjellsoftware.javafunctionalutils.ImmutableMap;
import com.fjellsoftware.retaildemo.autogenerated.orm.metrics.*;
import io.loppi.orm.MutationQueryExecutionResult;
import io.loppi.orm.PostgresExecutionException;
import io.loppi.orm.includablevalues.LongValue;
import io.loppi.orm.includablevalues.StringValue;
import io.loppi.orm.query.QueryExecutionPluralResult;
import io.loppi.orm.query.TableQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

public class Metrics {

    private static final String kindNamePrefix = "retaildemo_";
    public enum Kind{
        HTTP_TOTAL_INCOMING,
        HTTP_TOTAL_OUTGOING,
        HTTP_MISSING_OUTGOING,

        HTTP_200,
        HTTP_300,
        HTTP_400,
        HTTP_500,

        IP_RATE_LIMIT_TRIGGERS,
        LOGIN_RATE_LIMIT_TRIGGERS,

        LOGIN_SUCCESS,
        LOGIN_ERROR,

        CUSTOMER_QUERIES_SUCCESS,
        CUSTOMER_QUERIES_ERROR,
        CUSTOMER_MUTATIONS_SUCCESS,
        CUSTOMER_MUTATIONS_ERROR,
        PURCHASE_ORDER_SUCCESS,

        STAFF_QUERIES_SUCCESS,
        STAFF_QUERIES_ERROR,
        STAFF_MUTATIONS_SUCCESS,
        STAFF_MUTATIONS_ERROR,

        UNHANDLED_SERVER_EXCEPTION;

        public String toMetricName(){
            return kindNamePrefix + name().toLowerCase();
        }
    }

    private final Logger logger = LoggerFactory.getLogger(Metrics.class);
    private final MetricsORMService metricsService;
    private final MetricsDatabaseService databaseService;
    private final ImmutableMap<String, Long> initialMetricKindName_ids;
    private static final ImmutableMap<Kind, AtomicLong> metricCounter = initializeCounters();

    private static ImmutableMap<Kind, AtomicLong> initializeCounters(){
        Map<Kind, AtomicLong> counters = new HashMap<>();
        for (Kind value : Kind.values()) {
            counters.put(value, new AtomicLong(0));
        }
        return new ImmutableMap<>(counters);
    }

    public Metrics(MetricsORMService metricsService) {
        this.metricsService = metricsService;
        this.databaseService = metricsService.getDatabaseServiceJDBC();
        MetricsMeta meta = metricsService.getMeta();
        MetricKindMeta metricKindMeta = meta.getMetricKindMeta();
        MetricsDatabaseService databaseServiceJDBC = metricsService.getDatabaseServiceJDBC();
        int maximumNumberOfMetrics = 1000;
        TableQuery<MetricKindResult> query =
                databaseServiceJDBC.createTableQueryBuilder(metricKindMeta.getEntityMetadata(), maximumNumberOfMetrics)
                        .includeScalar(metricKindMeta.metricKindId)
                        .includeScalar(metricKindMeta.name)
                        .build();
        QueryExecutionPluralResult<MetricKindResult> queryResult;
        try {
            queryResult = databaseServiceJDBC.executeTableQuery(query);
        } catch (PostgresExecutionException e) {
            throw new ApplicationInternalException("Failed to fetch metric kinds.", e);
        }
        ImmutableList<MetricKindResult> deserialize = queryResult.deserialize();
        if(deserialize.size() == maximumNumberOfMetrics){
            throw new ApplicationInternalException("There may be more than 1000 kinds of metrics in the database, but" +
                    " Loppi server was not built to handle that.");
        }
        Map<String, Long> metricsKindName_Id = new HashMap<>();
        for (MetricKindResult metricKindResult : deserialize) {
            String kindName = ((StringValue) metricKindResult.getName()).value();
            long kindId = ((LongValue) metricKindResult.getMetricKindId()).value();
            metricsKindName_Id.put(kindName, kindId);
        }
        for (Kind value : Kind.values()) {
            findOrAddMetricKind(metricsKindName_Id, value.toMetricName());
        }
        this.initialMetricKindName_ids = new ImmutableMap<>(metricsKindName_Id);
    }

    private void findOrAddMetricKind(Map<String, Long> metricsKindName_Id, String kindName){
        Long kindIdOpt = metricsKindName_Id.get(kindName);
        if(kindIdOpt != null){
            return;
        }
        MetricsDatabaseService databaseService = metricsService.getDatabaseServiceJDBC();
        MetricKindMeta metricKindMeta = metricsService.getMeta().getMetricKindMeta();
        TableQuery<MetricKindResult> query = databaseService.createTableQueryBuilder(metricKindMeta.getEntityMetadata(), 1)
                .includeScalar(metricKindMeta.metricKindId)
                .where().eq(metricKindMeta.name, kindName).end().build();
        MutationQueryExecutionResult<MetricKindResult> executionResult;
        try {
            executionResult = databaseService.executeMutationQuery(List.of(new MetricKindToInsert(kindName)), query);
        } catch (PostgresExecutionException e) {
            throw new ApplicationInternalException(String.format("Failed to create new metric kind: [%s]", kindName), e);
        }
        long id = ((LongValue) executionResult.getQueryExecutionResult().deserialize().iterator().next().getMetricKindId()).value();
        metricsKindName_Id.put(kindName, id);
    }

    public void tryGatherAndStoreMetrics(){
        try {
            tryGatherAndStoreMetricsInternal();
        }catch (Exception e){
            logger.error("Failed to gather metrics.", e);
        }
    }

    private void tryGatherAndStoreMetricsInternal(){
        List<MetricsRowToMutate> metricRows = new ArrayList<>();
        Long httpMissingId = initialMetricKindName_ids.get(Kind.HTTP_MISSING_OUTGOING.toMetricName()).getOrThrow();
        long missing = metricCounter.get(Kind.HTTP_TOTAL_INCOMING).getOrThrow().get() -
                metricCounter.get(Kind.HTTP_TOTAL_OUTGOING).getOrThrow().get();
        metricRows.add(new MetricValueToInsert(new MetricsIdReferenceLong(httpMissingId), missing));
        for (ImmutableMap.Entry<Kind, AtomicLong> entry : metricCounter.entries()) {
            String metricKindName = entry.key().toMetricName();
            Long id = initialMetricKindName_ids.get(metricKindName).getOrThrow();
            metricRows.add(new MetricValueToInsert(new MetricsIdReferenceLong(id), entry.value().getAndSet(0)));
        }

        try {
            databaseService.executeMutation(metricRows);
        } catch (PostgresExecutionException e) {
            logger.error("Failed to submit metrics to database.", e);
        }
    }

    public static void incrementMetric(Kind kind){
        metricCounter.get(kind).getOrThrow().incrementAndGet();
    }

}
