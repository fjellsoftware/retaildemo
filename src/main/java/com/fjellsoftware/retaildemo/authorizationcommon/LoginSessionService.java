/*
 * Â© 2023. This work is openly licensed via CC0 1.0.
 * https://creativecommons.org/publicdomain/zero/1.0/
 */

package com.fjellsoftware.retaildemo.authorizationcommon;

import com.fjellsoftware.javafunctionalutils.ImmutableList;
import com.fjellsoftware.javafunctionalutils.opt.Opt;
import com.fjellsoftware.retaildemo.authorizationcommon.userinfo.AuthenticatedUser;
import com.fjellsoftware.retaildemo.authorizationcommon.userinfo.UserInfo;
import com.fjellsoftware.retaildemo.autogenerated.orm.main.*;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.loppi.orm.includablevalues.UUIDValue;
import io.loppi.orm.query.TableQuery;
import io.loppi.orm.PostgresExecutionException;
import io.loppi.orm.includablevalues.AssociationValue;
import io.loppi.orm.includablevalues.StringValue;


import java.net.InetAddress;
import java.time.OffsetDateTime;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

public class LoginSessionService {

    private final Cache<UUID, UserInfo> userTokenCache;
    private final RetailDemoDatabaseService databaseServiceJDBC;
    private final UserAccountMeta userAccountMeta;
    private final LoginSessionMeta loginSessionMeta;

    public LoginSessionService(RetailDemoDatabaseService databaseServiceJDBC, RetailDemoMeta meta) {
        this.databaseServiceJDBC = databaseServiceJDBC;
        this.userAccountMeta = meta.getUserAccountMeta();
        this.loginSessionMeta = meta.getLoginSessionMeta();
        this.userTokenCache = Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .maximumSize(100_000)
                .build();
    }

    public Opt<UserInfo> getUserInfoFromCacheOrFetch(
            UUID sessionToken, InetAddress remoteAddress) throws PostgresExecutionException {
        UserInfo fromCacheOrNull = userTokenCache.getIfPresent(sessionToken);
        if(fromCacheOrNull != null) {
            return Opt.of(fromCacheOrNull);
        }
        TableQuery<LoginSessionResult> query = databaseServiceJDBC.createTableQueryBuilder(loginSessionMeta.getEntityMetadata(), 1)
                .includeOwnerAttribute(loginSessionMeta.userAccount)
                    .includeScalar1(userAccountMeta.userAccountId)
                    .includeScalar1(userAccountMeta.username)
                    .includeScalar1(userAccountMeta.role)
                .end1()
                .where()
                .eq(loginSessionMeta.loginSessionId, sessionToken)
                .eq(loginSessionMeta.isSignedOut, false)
                .gt(loginSessionMeta.createdAt, OffsetDateTime.now().minusHours(25))
                .end().build();
        ImmutableList<LoginSessionResult> userSessions = databaseServiceJDBC.executeTableQuery(query).deserialize();
        if(userSessions.isEmpty()){
            return Opt.empty();
        }
        LoginSessionResult userSession = userSessions.iterator().next();
        UserAccountResult user = ((AssociationValue<UserAccountResult>) userSession.getUserAccount()).value();
        UUID userId = ((UUIDValue) user.getUserAccountId()).value();
        String username = ((StringValue) user.getUsername()).value();
        String roleName = ((StringValue) user.getRole()).value();
        RoleEnum userInfoRole = RoleEnum.valueOf(roleName);
        UserInfo userInfo = new AuthenticatedUser(userId, username, userInfoRole, sessionToken, remoteAddress);
        userTokenCache.put(sessionToken, userInfo);
        return Opt.of(userInfo);
    }

    public void invalidateSession(UUID sessionToken){
        userTokenCache.invalidate(sessionToken);
    }
}
